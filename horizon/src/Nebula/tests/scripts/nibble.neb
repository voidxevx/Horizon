// single line comment 
/*
	multi line comment
*/

// global function -> accessable anywhere
/*
	global functions can be called by any object at any time without any root access or component requirements.
	because of this they cannot directly access components unless passed a specific entity type.

	the global function "root" is the function that will be called when the state is created.

	global root(): void
	{
		...
	}
*/
global squareAdd(a: i32, b: i32): i32
{
	return a * a + b;
}

// custom data types
/*
	Custom data types let you bundle together data without creating a component.

	Types can have public or private data members and methods (no inheritance exists so protected types are not possible.)
	Types must implement at least one constructor. Alternate overloads can be created to initialize the data in other ways.
	
	public/private methods signatures must include the keyword method, not function. The public and private keywords are optional but the method is private by default.
		(public/private) method name(...) {...}
	Operator overloads can optionally be implemented but cannot be marked as public or private.
		operator(symbol)(...) {...}
/*
type Vec2
{
	private x: i32;
	private y: i32;

	contructor(x: i32, y: i32) {
		this_x = x;
		this_y = y;
	}

	operator+(other: Vec2): Vec2 {
		return Vec2(other_getY() + this_x, other_getX() + this_y);
	}

	// operators not implemented will generate compilation errors if called.

	public method getX(): i32 {
		return this_x;
	}

	public method getY(): i32 {
		return this_y;
	}
}

// enumeration types
/*
	Enums work the same as in most languages though they cant have methods.
*/
enum Classes 
{
	Mage,
	Wizard,
	Warrior,
	Rogue,
}

// component types -> data ownable by entities
/*
	Components are data that can be attached to an entity (either at runtime or from an archetype.)

	Components, like types can implement methods that edit their own data.
	Methods can't have a accessability tag and are public by default.
*/
component TransformComponent
{
	location: vec2;
	rotation: i32;
	scale: vec2;

	method getTransform(): mat4 {
		// ...
	}
}

// entity archetype
/*
	Archetypes hold a list of components that will automatically be attached to a entity when created.
	Components attached by an archetype cannot be attached or dropped at runtime. 

	Archetypes can implement functions (not methods) that can access and edit the data and methods of the attached components.
*/
arch Enemy [DamageComponent, TransformComponent, SpriteComponent]
{
	function attack(): void
	{
		// ...
	}
}

// entity interface
/*
	Interfaces hold a list of functions that can be called on an entity without knowing if that entity has the correct components.

	Interface components have a list of components that will be checked at runtime before calling the function.
	If the entity doesn't have the correct components a fallback can optionally be implemented.
	no fallback:
		entityVar try functionName(...) from InterfaceName;
	fallback (function returns void):
		entityVar try functionName(...) from InterfaceName else {...}
	fallback (function return value):
		entityVar try functionName(...) from InterfaceName else (matching value/function)
*/
interface DamageAble
{
	requires [DamageComponent]
	function takeDamage(amount: i32): bool
	{
		return DamageComponent_takeDamage(amout);
	}

}

// entity trait
/*
	Traits are methods that can be implemented for individual entities with the select required components.
	An entity must be known to implement the trait at compile time in order to call the methods.
*/
trait Printable []
{
	print(): void;
	debugPrint(): void;
}

// entity trait interface
/*
	Trait interfaces are similar to normal traits except each function requires specific components.
	Methods are still implemented individually for entities.

	Trait interface methods can be called without knowing the components owned by the entity

	interface trait methods are called with the same syntax as interface functions.
		entityVar try methodName(...) from TraitName (else ...)
*/
trait interface AttackAble
{
	attack(): void requires [DamageComponent];
	heal(): void requires [DamageComponent];
}

// entity type
/*
	Entities are the main objects that are created.
	Entities can inherit from multiple archetypes adding the collective components.

	Entities cannot have methods or functions without inheriting one from a trait.
	Entities must have at least one constructor that will be called when the entity is created.
	creation syntax:
		new EntityName(...);
	detroy syntax:
		destroy entityVar;

	Components can be added or dropped from an entity as long as it doesn't already own that component or inherits it from a archetype.
	Fallbacks can be implemented to attaching or dropping a component.
	attach -
		no fallback:
			attach ComponentName(...) to entityVar;
		fallback:
			try attach ComponentName(...) to entityVar else {...}
	drop -
		no fallback:
			drop ComponentName from entityVar;
		fallback:
			try drop ComponentName from entityVar else {...}

*/
entity Player [Avatar]
{
	constructor()
	{
		// ...
	}

	trait Printable {
		print(): void 
		{
			// ...
		}
		debugPrint(): void
		{
			// ...
		}
	}

	trait interface Attackable {
		// ...
	}

}

// system
/*
	systems interact with entities of specific archetypes or components.
	When an entity is created with specified components or archetype it will be added to the systems call list.

	When an entity is created it will call the deligate: on new.
	similarly deleting an enitity will call the deligate: on destroy.
	each game tick will call the deligate: on update for each entity on the system (deltaTime is a accessable variable within the scope).

	Each deligate function has the entity as the scopes root allowing direct access to its components using the this variable.
*/
system RenderSystem [Avatar]
{
	on new {
		// ...
	}

	on destroy {
		// ...
	}

	on update {
		// ...
	}
}